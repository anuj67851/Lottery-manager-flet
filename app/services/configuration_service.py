import logging

from sqlalchemy.orm import Session
import os
from cryptography.fernet import Fernet, InvalidToken # For encryption

from app.config import VERSION, VERSION_CONFIG, LICENSE_FILE_PATH, LICENSE_ENCRYPTION_KEY
from app.data import crud_configurations
from app.core.models import Configuration
from app.core.exceptions import DatabaseError, AppException

logger = logging.getLogger("lottery_manager_app")

class LicenseFileError(AppException):
    """Custom exception for license file operations."""
    pass

class ConfigurationService:
    def __init__(self):
        # Ensure the key is 32 bytes for Fernet if Fernet is used directly with AES256 key
        # Fernet.generate_key() produces a URL-safe base64-encoded 32-byte key.
        # If LICENSE_ENCRYPTION_KEY is a raw AES key, it needs to be base64 encoded for Fernet.
        # For simplicity, let's assume LICENSE_ENCRYPTION_KEY is already a Fernet-compatible key
        # or we derive one for Fernet here.
        # A simpler approach for a fixed key is to use a base64 encoded version of a raw 32-byte key.

        # Ensure the key is properly formatted for Fernet (URL-safe base64 encoded 32 bytes)
        # If LICENSE_ENCRYPTION_KEY is just a random 32-byte string, it needs to be base64 encoded.
        # fernet_key = base64.urlsafe_b64encode(LICENSE_ENCRYPTION_KEY) # This would be for a raw AES key
        # However, Fernet expects a key generated by Fernet.generate_key() or similar.
        # Let's use the LICENSE_ENCRYPTION_KEY directly if it's already Fernet-style,
        # or if it's a raw key, we should adjust.
        # For this example, assuming LICENSE_ENCRYPTION_KEY is a suitable Fernet key.
        # If it's just a password-like string, it's not directly usable by Fernet.
        # Let's assume it's a base64 encoded 32-byte key.
        try:
            # If LICENSE_ENCRYPTION_KEY is intended to be a Fernet key (urlsafe base64 encoded 32 random bytes)
            # it should be used directly. If it's a passphrase, a KDF should be used.
            # Given it's named _KEY, let's assume it's a direct Fernet key.
            self.fernet = Fernet(LICENSE_ENCRYPTION_KEY)
        except ValueError as e:
            logger.error(f"CRITICAL: Invalid LICENSE_ENCRYPTION_KEY format for Fernet: {e}. Ensure it's a URL-safe base64-encoded 32-byte key.", exc_info=True)
            # Fallback to a dummy fernet object to prevent app crash, though encryption will be broken.
            # In a real scenario, you might want to halt the app or use a default (insecure) key.
            dummy_key = Fernet.generate_key()
            logger.error(f"Warning: Using a dummy encryption key due to invalid configured key. License security compromised. Dummy key: {dummy_key.decode()}", exc_info=True)
            self.fernet = Fernet(dummy_key)


    # --- License File Methods ---
    def _read_license_status_from_file(self) -> bool:
        if not LICENSE_FILE_PATH.exists():
            return False
        try:
            with open(LICENSE_FILE_PATH, 'rb') as f: # Read as bytes
                encrypted_data = f.read()
            if not encrypted_data: # Handle empty file case
                return False

            decrypted_data = self.fernet.decrypt(encrypted_data)
            status_str = decrypted_data.decode().strip().lower()
            return status_str == "true"
        except InvalidToken: # This means decryption failed (bad key, or tampered/corrupt file)
            logger.error(f"Error: License file at {LICENSE_FILE_PATH} is tampered, corrupt, or encrypted with a different key.")
            # Optionally, delete or rename the invalid file to force recreation with default.
            # For now, treat as inactive.
            try:
                os.remove(LICENSE_FILE_PATH)
                logger.warning(f"Removed invalid license file: {LICENSE_FILE_PATH}")
            except OSError as ose:
                logger.error(f"Could not remove invalid license file {LICENSE_FILE_PATH}: {ose}", exc_info=True)
            return False
        except Exception as e:
            logger.error(f"Error reading or decrypting license file {LICENSE_FILE_PATH}: {type(e).__name__} - {e}", exc_info=True)
            return False

    def _write_license_status_to_file(self, is_active: bool) -> None:
        try:
            LICENSE_FILE_PATH.parent.mkdir(parents=True, exist_ok=True)
            status_str = "true" if is_active else "false"
            encrypted_data = self.fernet.encrypt(status_str.encode())
            with open(LICENSE_FILE_PATH, 'wb') as f: # Write as bytes
                f.write(encrypted_data)
        except Exception as e:
            raise LicenseFileError(f"Could not write to encrypted license file {LICENSE_FILE_PATH}: {type(e).__name__} - {e}")

    def ensure_license_file_exists(self, default_active_status: bool = False) -> None:
        if not LICENSE_FILE_PATH.exists():
            try:
                logger.warning(f"License file not found at {LICENSE_FILE_PATH}. Creating with encrypted status: {'Active' if default_active_status else 'Inactive'}")
                self._write_license_status_to_file(default_active_status)
            except LicenseFileError as e:
                logger.error(f"CRITICAL: Failed to create initial encrypted license file: {e.message}", exc_info=True)
                pass

    def get_license_status(self) -> bool:
        return self._read_license_status_from_file()

    def set_license_status(self, license_activated: bool) -> None:
        try:
            self._write_license_status_to_file(license_activated)
        except LicenseFileError as e:
            raise DatabaseError(e.message) # Or a more specific LicenseUpdateError

    # --- Version DB Methods ---
    def get_version(self, db: Session) -> Configuration | None:
        return crud_configurations.crud_get_version(db)

    def create_version(self, db: Session) -> Configuration:
        new_version_config = crud_configurations.crud_create_configuration(db, name=VERSION_CONFIG, value=VERSION)
        return new_version_config